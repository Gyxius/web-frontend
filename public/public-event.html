<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Event â€” Public View</title>
  <!-- Leaflet for map (needed because this is a standalone static page) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root{
      --bg:#F7F7F5; --card:#FFFFFF; --text:#111827; --muted:#6B7280; --primary:#58CC02; --accent:#1CB0F6; --border:#EEF2F7;
    }
  body { font-family: Inter, Roboto, 'Nunito Sans', Arial, system-ui, -apple-system, 'Segoe UI', 'Helvetica Neue', sans-serif; background:var(--bg); color:var(--text); padding:22px; }
  
  .title { font-size:44px; font-weight:900; margin-bottom:6px; color:var(--text); line-height:1; }
  .meta { color:var(--muted); margin-bottom:10px; font-size:16px }
  .desc { color:var(--text); line-height:1.45; margin-top:6px }
  .section { margin-top:18px; }
  .sectionTitle { font-size:18px; font-weight:900; color:var(--text); margin-bottom:12px; display:flex; align-items:center; gap:8px }
  .section strong, .sectionTitle strong { display:block; font-weight:800; margin-bottom:8px }
    .avatar { width:56px; height:56px; border-radius:12px; display:inline-block; vertical-align:middle; margin-right:12px; object-fit:cover }
    .attendee { display:flex; align-items:center; gap:12px; padding:10px 0; border-bottom:1px solid #F3F4F6 }
  .host-card{display:flex;align-items:center;gap:16px;padding:16px;background:var(--bg);border-radius:12px}
  .host-info {font-weight:700}
  .host-sub { color:var(--muted); font-size:14px; margin-top:6px }
  .language-badge{display:inline-block;background:#F3F4F6;padding:6px 12px;border-radius:999px;margin-right:8px;font-weight:700;font-size:14px}
  /* languages green panel */
  #languagesSection { padding:12px; border-radius:12px; }
  #languagesSection .lang-panel { background: linear-gradient(135deg, var(--primary), #37B300); padding:14px; border-radius:12px; }
  #languagesSection .lang-panel .language-badge{background:white; color:var(--text); margin-right:8px}
  .chat { background:var(--card); padding:16px; border-radius:16px; margin-bottom:12px; border:1px solid var(--border); }
  .chat-msg { padding:12px 10px; border-bottom:1px solid #F3F4F6 }
  .chat-msg .who{font-weight:800;margin-bottom:6px;color:var(--muted); font-size:14px}
  .chat-avatar { width:40px; height:40px; border-radius:50%; flex-shrink:0; object-fit:cover }
  .message-text { margin-top:4px; color:var(--text); font-size:15px }
  .chat-msg { padding:8px 12px; }
  .bubble { max-width:68%; padding:12px 14px; border-radius:14px; background:var(--card); box-shadow:0 4px 12px rgba(2,6,23,0.06); border:1px solid #EEF2F7; }
  .bubble .bubble-header { font-weight:800; color:var(--muted); font-size:13px; margin-bottom:6px }
  .bubble.me { background: linear-gradient(135deg,#58CC02,#37B300); color:white; border:none; box-shadow:0 8px 20px rgba(56,186,43,0.18) }
  .bubble.me .bubble-header { color: rgba(255,255,255,0.95); }
  .chat-row { display:flex; align-items:flex-start; gap:12px }
  .chat-row.left { justify-content:flex-start }
  .chat-row.right { justify-content:flex-end }
  .chat-row.right .bubble { max-width:56%; }
  .chat-row.right .chat-avatar { order: 2 }
  .chat-row.right .bubble { order: 1; border-radius:16px 16px 16px 8px }
  .chat-row.left .bubble { border-radius:16px 16px 8px 16px }
  .btn { display:inline-block; padding:10px 16px; border-radius:12px; background:var(--primary); color:white; text-decoration:none; font-weight:900; border:none; box-shadow:0 6px 16px rgba(88,204,2,0.28) }
    .btn.secondary { background:#3B82F6 }
    .copy { margin-left:12px; font-size:13px; color:var(--muted) }

  /* host avatar match app */
  .host-card .avatar { width:64px; height:64px; border-radius:50%; background:var(--card); border:2px solid var(--border); }
  .attendee .avatar { width:56px; height:56px; border-radius:12px }
  /* attendee card style */
  .attendee { background:var(--card); border-radius:10px; padding:12px; margin-bottom:10px }
  .card-white { background:white; border-radius:12px; padding:14px; border:1px solid var(--border); box-shadow:0 1px 3px rgba(0,0,0,0.04); margin-bottom:12px }
  .meta-row { display:flex; gap:12px; align-items:center; color:var(--muted); margin-top:8px }
  .meta-badge { display:inline-flex; align-items:center; gap:8px; background:#F3F4F6; padding:8px 12px; border-radius:12px; font-weight:700 }
  .addr { color:var(--muted); font-size:13px; margin-top:6px }
  .attendee-card { display:flex; gap:12px; align-items:center; padding:12px; background:white; border-radius:12px; border:1px solid var(--border); margin-bottom:10px }
  .chat-input-row { display:flex; gap:8px; margin-top:12px; align-items:center }
  .chat-input { flex:1; padding:10px 12px; border-radius:999px; border:1px solid var(--border); }
  .small-flag { font-size:18px; margin-right:8px }
  /* header bar */
  #headerBar a { font-size:20px }
  #headerBar .btn { padding:8px 12px }
  /* banner and top layout tweaks */
  #map { height:220px; border-radius:12px; overflow:hidden; box-shadow:0 6px 18px rgba(2,6,23,0.06); }
  </style>
</head>
<body>

  <!-- Page content required by the live-update script -->
  <!-- header intentionally minimal for public page (no share/open-in-app/home) -->

  <div class="card">
    <div id="banner" style="display:none; background-size:cover; background-position:center; height:160px; border-radius:12px; margin-bottom:14px;"></div>
    <div>
      <div class="title">Event</div>
      <div id="meta" class="meta">Location Â· Venue Â· Date</div>
      <div id="desc" class="desc" style="margin-top:12px;">Short event description</div>
    </div>

    <div id="mapWrap" style="display:none; margin-top:16px;">
      <div id="map"></div>
    </div>

    <div id="aboutSection" class="section" style="display:none;">
      <div class="sectionTitle">About</div>
      <div id="aboutContent"></div>
    </div>

    <div id="languagesSection" style="display:none; margin-top:12px;">
      <div id="languages"></div>
    </div>

    <div id="basedOn" style="display:none; margin-top:12px;">
      <div id="basedContent"></div>
    </div>

    <div style="margin-top:16px;">
      <div id="host"></div>
    </div>

    <div style="margin-top:16px;">
      <div id="attendees"></div>
    </div>
  </div>

  <div class="card">
    <div class="sectionTitle">Group Chat</div>
    <div id="chat" class="chat">Loading chatâ€¦</div>
  </div>

  <!-- We'll refresh the event and chat periodically so the shared page stays live. -->
  <script>
  document.addEventListener('DOMContentLoaded', function(){
  (async function(){
  let currentEvent = null;
  // track whether this is the initial load so we don't show a big "Loadingâ€¦" on every poll
  let initialLoad = true;
  let map = null;
  let marker = null;

  const API_URL = 'https://fast-api-backend-qlyb.onrender.com';
  const params = new URLSearchParams(window.location.search);
  const id = params.get('event') || params.get('id');
  const titleEl = document.querySelector('.title');
  const metaEl = document.getElementById('meta');
  const descEl = document.getElementById('desc');
  const attendeesEl = document.getElementById('attendees');

  if (!id) {
    titleEl.textContent = 'No event specified';
    metaEl.textContent = 'Open link like ?event=123';
    // stop here â€” nothing to do
  }

  function avatarForLocal(local) {
    if (local && local.avatar && local.avatar.provider === 'dicebear') return `https://api.dicebear.com/6.x/${local.avatar.style}/svg?seed=${encodeURIComponent(local.avatar.seed)}`;
    const emoji = (local && local.emoji) ? local.emoji : null;
    let label = emoji || (local && local.name ? String(local.name)[0].toUpperCase() : '?');
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='56' height='56'><rect width='100%' height='100%' fill='%23EEE'/><text x='50%' y='50%' font-size='28' dominant-baseline='middle' text-anchor='middle'>${label}</text></svg>`;
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  }

  async function fetchEvent() {
    try {
      // re-query DOM refs in case the DOM changed (prevents null errors)
  const titleElLocal = document.querySelector('.title');
  const metaElLocal = document.getElementById('meta');
  const descElLocal = document.getElementById('desc');
  const attendeesElLocal = document.getElementById('attendees');
      if (!titleElLocal || !metaElLocal || !descElLocal || !attendeesElLocal) {
        console.warn('fetchEvent: missing DOM refs', { titleEl: !!titleElLocal, metaEl: !!metaElLocal, descEl: !!descElLocal, attendeesEl: !!attendeesElLocal });
        return;
      }
      // show a friendly loading state only on the first load (avoid layout jumps on polling)
      if (initialLoad) {
        titleElLocal.textContent = 'Loadingâ€¦';
        metaElLocal.textContent = '';
      }

      const res = await fetch(`${API_URL}/api/events/${encodeURIComponent(id)}`);
      if (!res.ok) {
        // show a clear message for a 404, otherwise surface a generic network error
        if (res.status === 404) {
          titleElLocal.textContent = 'Event not found';
          metaElLocal.textContent = '';
          descElLocal.textContent = '';
          attendeesElLocal.textContent = '';
          return;
        }
        throw new Error('Network error: ' + res.status);
      }
      const ev = await res.json();
      // If event changed (or first load), update relevant UI parts
      // Simple change detection by comparing JSON string - sufficient here
      const prev = JSON.stringify(currentEvent);
      const now = JSON.stringify(ev);
      if (prev === now && currentEvent !== null) return; // no change
  currentEvent = ev;
  // mark that we've completed the initial load â€” subsequent polls shouldn't replace the title
  initialLoad = false;

      // title/banner
  titleElLocal.textContent = ev.name || 'Event';
      const banner = document.getElementById('banner');
  if (ev.imageUrl && banner) { banner.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.25), rgba(0,0,0,0.25)), url(${ev.imageUrl})`; banner.style.display = 'block'; }

      // clear/insert city/venue/address if they changed
      // remove existing helpers then re-insert
      ['city','venue','fulladdr'].forEach(c => { const el = document.querySelector('.' + c); if (el) el.remove(); });
      const cityText = ev.city || (ev.location ? String(ev.location).split(',')[0] : '');
      if (cityText) { const cityEl = document.createElement('div'); cityEl.className = 'city'; cityEl.textContent = cityText; titleEl.parentNode.insertBefore(cityEl, titleEl.nextSibling); }
      if (ev.venue) { const venueEl = document.createElement('div'); venueEl.className = 'venue'; venueEl.textContent = ev.venue; const after = titleEl.nextSibling || titleEl; after.parentNode.insertBefore(venueEl, after.nextSibling); }
      const addrLine2 = ev.address || ev.venue || ev.location || '';
      if (addrLine2) { const addrEl = document.createElement('div'); addrEl.className = 'fulladdr'; addrEl.textContent = addrLine2; const ref = document.querySelector('.venue') || document.querySelector('.city') || titleEl; ref.parentNode.insertBefore(addrEl, ref.nextSibling); }

      // description
      const aboutSection = document.getElementById('aboutSection');
      const aboutContent = document.getElementById('aboutContent');
      if (aboutSection && aboutContent) {
        if (ev.description) { aboutSection.style.display = 'block'; aboutContent.innerHTML = `<div>${ev.description}</div>`; } else { aboutSection.style.display = 'none'; }
      }

      // languages
      const langEl = document.getElementById('languages');
      if (ev.languages && ev.languages.length > 0) {
        document.getElementById('languagesSection').style.display = 'block';
        const langFlag = { 'French':'ðŸ‡«ðŸ‡·', 'English':'ðŸ‡¬ðŸ‡§', 'Polish':'ðŸ‡µðŸ‡±', 'Spanish':'ðŸ‡ªðŸ‡¸' };
        langEl.innerHTML = `<div class="lang-panel">${ev.languages.map(l => `<span class="language-badge"><span class="small-flag">${langFlag[l] || ''}</span>${l}</span>`).join('')}</div>`;
      } else { document.getElementById('languagesSection').style.display = 'none'; }

      // based on
      if (ev.templateEventName) { document.getElementById('basedOn').style.display = 'block'; document.getElementById('basedContent').innerHTML = `<div style="font-weight:700">${ev.templateEventName}</div><div style="color:#666;font-size:13px">${ev.templateEventVenue || ''} Â· ${ev.templateEventDate || ''}</div>`; } else { document.getElementById('basedOn').style.display = 'none'; }

  // host (compact format)
  // mapping of country names to flag emojis (used for host and attendees)
  const countryFlagMap = { 'France':'ðŸ‡«ðŸ‡·', 'Madagascar':'ðŸ‡²ðŸ‡¬', 'Poland':'ðŸ‡µðŸ‡±', 'United Kingdom':'ðŸ‡¬ðŸ‡§', 'England':'ðŸ‡¬ðŸ‡§' };
      const hostEl = document.getElementById('host');
      if (!hostEl) {
        console.warn('fetchEvent: host element missing');
      } else {
        const hostName = (typeof ev.host === 'string') ? ev.host : (ev.host && typeof ev.host.name === 'string') ? ev.host.name : (ev.created_by || ev.createdBy || '');
        let hostLocal = null;
        try { if (hostName) { hostLocal = localStorage.getItem('userProfile_' + hostName); hostLocal = hostLocal ? JSON.parse(hostLocal) : null; } } catch(e) {}
        // If we don't have a local profile, try to fetch a public profile from the backend and cache it
        async function fetchProfileIfMissing(username, force = false) {
          if (!username) return null;
          // if not forcing, prefer a cached profile that looks complete
          if (!force) {
            try {
              const cached = localStorage.getItem('userProfile_' + username);
              if (cached) {
                const parsed = JSON.parse(cached);
                if (parsed.university && parsed.languageLevels) return parsed;
                // otherwise we'll attempt to fetch below
              }
            } catch(e) {}
          }
          // try fetching the canonical profile from server
          try {
            const resp = await fetch(`${API_URL}/api/users/${encodeURIComponent(username)}/profile`);
            if (resp.ok) {
              const json = await resp.json();
              try { localStorage.setItem('userProfile_' + username, JSON.stringify(json)); } catch(e) {}
              return json;
            }
          } catch(e) {
            // ignore network errors
          }
          // fallback: return whatever cached value we have (may be null)
          try { return JSON.parse(localStorage.getItem('userProfile_' + username)); } catch(e) { return null; }
        }
        // For the host prefer the server's canonical profile (force a fetch so server wins over stale local cache)
        try { hostLocal = await fetchProfileIfMissing(hostName, true); } catch(e) {}

        function humanLangs(levelsObj) {
          if (!levelsObj) return '';
          return Object.entries(levelsObj).map(([lang, level]) => {
            const cap = String(level).charAt(0).toUpperCase() + String(level).slice(1);
            return `${cap} ${lang}`;
          }).join(', ');
        }

        const hostLangsFormatted = humanLangs(hostLocal && hostLocal.languageLevels);
        const hostNameText = (hostLocal && hostLocal.name) || hostName || '';
        const flags = (hostLocal && hostLocal.homeCountries) ? hostLocal.homeCountries.map(c => countryFlagMap[c] || c).join(' ') : '';

        hostEl.innerHTML = `
          <div class="sectionTitle">ðŸ‘¤ Hosted by</div>
          <div class="card-white">
            <div class="host-card">
              <img class="avatar" src="${avatarForLocal(hostLocal)}" />
              <div>
                <div class="host-info">${hostNameText} ${flags}</div>
                <div class="host-sub">${hostLocal && hostLocal.university ? hostLocal.university : ''}</div>
                <div class="host-sub">${hostLangsFormatted}</div>
              </div>
            </div>
          </div>
        `;
      }

      // attendees: re-render in compact format
      attendeesElLocal.innerHTML = '';
      const participants = ev.participants || [];
      if (participants.length === 0) {
        attendeesElLocal.textContent = 'No attendees yet';
      } else {
        const countHeader = document.createElement('div');
        countHeader.style.fontWeight = '800';
        countHeader.style.marginBottom = '8px';
        countHeader.textContent = `ðŸ§ƒ Attendees (${participants.length})`;
        attendeesElLocal.appendChild(countHeader);

        // Resolve attendee profiles (use cached localStorage when available, otherwise fetch from backend)
        const profilePromises = participants.map(async p => {
          let local = null;
          try { local = localStorage.getItem('userProfile_' + p); local = local ? JSON.parse(local) : null; } catch(e) {}
          if (!local) {
            try { local = await fetchProfileIfMissing(p); } catch(e) { local = null; }
          }
          return { username: p, profile: local };
        });
        const resolved = await Promise.all(profilePromises);
        resolved.forEach(({ username, profile: local }) => {
          const levelsFormatted = humanLangs(local && local.languageLevels);
          const flags = (local && local.homeCountries) ? (local.homeCountries.map(c => countryFlagMap[c] || c).join(' ')) : '';

          const item = document.createElement('div');
          item.className = 'attendee-card';
          item.innerHTML = `
            <img class="avatar" src="${avatarForLocal(local)}" />
            <div>
              <div style="font-weight:800">${(local && local.name) || username} ${flags}</div>
              <div class="host-sub">${local && local.university ? local.university : ''}</div>
              <div class="host-sub">${levelsFormatted}</div>
            </div>
          `;
          attendeesElLocal.appendChild(item);
        });
      }

      // map: initialize once, update marker position if coordinates present
      if (ev.coordinates && (ev.coordinates.lat || ev.coordinates.latitude)) {
        const coords = ev.coordinates.lat ? { lat: ev.coordinates.lat, lng: ev.coordinates.lng } : { lat: ev.coordinates.latitude, lng: ev.coordinates.longitude };
        try {
          const mapWrap = document.getElementById('mapWrap');
          // reveal map without stealing focus or causing browser scroll
          mapWrap.style.display = 'block';
          if (!map) {
            // disable keyboard interactions so the map doesn't grab focus/scroll
            map = L.map('map', { keyboard: false, tap: false }).setView([coords.lat, coords.lng], 15, { animate: false });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Â© OpenStreetMap' }).addTo(map);
            marker = L.marker([coords.lat, coords.lng]).addTo(map);
            // ensure the map container is not focusable which can cause the browser to scroll to it
            try { map.getContainer().tabIndex = -1; } catch (e) {}
          } else {
            // update marker position without animating the map (avoid panning/scrolling)
            marker.setLatLng([coords.lat, coords.lng]);
            try {
              const cur = map.getCenter();
              const lat = Number(cur.lat || 0), lng = Number(cur.lng || 0);
              const dLat = Math.abs(lat - Number(coords.lat));
              const dLng = Math.abs(lng - Number(coords.lng));
              // only reset view if location changed noticeably
              if (dLat > 0.0001 || dLng > 0.0001) {
                map.setView([coords.lat, coords.lng], map.getZoom(), { animate: false });
              }
            } catch (e) {
              // fallback: set view silently
              try { map.setView([coords.lat, coords.lng], map.getZoom(), { animate: false }); } catch (e) {}
            }
          }
        } catch (e) { console.warn('Leaflet init failed', e); }
      }

  // No share/open-in-app/home controls on the public page
    } catch (e) {
      console.warn('fetchEvent failed', e);
      // show a gentle error message (distinct from "Event not found") for network/other failures
      try { titleElLocal.textContent = 'Could not load event'; } catch(_) {}
      try { metaElLocal.textContent = ''; } catch(_) {}
    }
  }

  // fetch chat and re-render messages (read-only)
  async function fetchChat() {
    const chatEl = document.getElementById('chat');
    if (!chatEl) { console.warn('fetchChat: chat element not found'); return; }
    chatEl.innerHTML = '';
    try {
      const chatRes = await fetch(`${API_URL}/api/chat/${encodeURIComponent(id)}`);
      if (chatRes.ok) {
        const chatMsgs = await chatRes.json();
        if (Array.isArray(chatMsgs) && chatMsgs.length > 0) {
          chatMsgs.forEach(m => {
            const msgRow = document.createElement('div');
            msgRow.className = 'chat-msg';

            // Determine if this message should be shown as "me" (right side)
            let sessionUser = null;
            try { const raw = localStorage.getItem('sessionUser'); sessionUser = raw ? JSON.parse(raw) : null; } catch(e) { sessionUser = null; }
            const currentName = sessionUser?.username || sessionUser?.name || 'You';
            const isMe = (String(m.username).toLowerCase() === String(currentName).toLowerCase()) || (String(m.username).toLowerCase() === 'you');

            const row = document.createElement('div');
            row.className = 'chat-row ' + (isMe ? 'right' : 'left');

            // load profile to show avatar if available
            let profile = null;
            try { const raw = localStorage.getItem('userProfile_' + m.username); profile = raw ? JSON.parse(raw) : null; } catch(e) { profile = null; }
            const avatarImg = document.createElement('img');
            avatarImg.className = 'chat-avatar';
            avatarImg.src = avatarForLocal(profile);

            const bubble = document.createElement('div');
            bubble.className = 'bubble' + (isMe ? ' me' : '');
            const header = document.createElement('div'); header.className = 'bubble-header'; header.textContent = (isMe ? 'You' : m.username);
            const msgDiv = document.createElement('div'); msgDiv.className = 'bubble-text'; msgDiv.textContent = m.message;
            bubble.appendChild(header);
            bubble.appendChild(msgDiv);

            if (isMe) {
              // right: bubble then avatar
              row.appendChild(bubble);
              row.appendChild(avatarImg);
            } else {
              // left: avatar then bubble
              row.appendChild(avatarImg);
              row.appendChild(bubble);
            }

            msgRow.appendChild(row);
            chatEl.appendChild(msgRow);
          });
        } else { chatEl.textContent = 'No messages yet'; }
      } else { chatEl.textContent = 'No messages yet'; }
    } catch (e) { chatEl.textContent = 'No messages yet'; }
  }

  // initial load and polling intervals
  fetchEvent(); fetchChat();
  // refresh event every 10s, chat every 3s for near-real-time
  setInterval(fetchEvent, 10000);
  setInterval(fetchChat, 3000);

  // expose a manual refresh (optional) - not necessary but helpful for debugging
  window.__fetchEvent = fetchEvent; window.__fetchChat = fetchChat;

  })();
  });
</script>
</body>
</html>